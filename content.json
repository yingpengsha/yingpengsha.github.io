{"meta":{"title":"YINGPENGSHA","subtitle":"coder","description":"Pease & Love","author":"应鹏沙","url":"https://yingpengsha.github.io"},"pages":[{"title":"","date":"2018-08-31T06:33:37.744Z","updated":"2018-08-31T06:33:37.744Z","comments":true,"path":"404.html","permalink":"https://yingpengsha.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2018-08-31T07:47:23.734Z","updated":"2018-08-31T07:47:23.734Z","comments":true,"path":"README.html","permalink":"https://yingpengsha.github.io/README.html","excerpt":"","text":"yingpengsha’s blogHi, this is yingpengsha’s blog. You can click here(https://yingpengsha.github.io) to visit."},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2019-03-26T04:52:52.540Z","comments":true,"path":"about/index.html","permalink":"https://yingpengsha.github.io/about/index.html","excerpt":"","text":"AboutMe你好，我是 yingpengsha，自我意识旺盛所以没有合适的网名。 就读于 绍兴文理学院 绍兴大学，现在 大一大二 大三。 可能会成为程序员，从事前端（正在学习机器学习中），擅长ECMAScript 6、Typescript、React.js、React-Native、Vue.js。 有个工作室FEARLESS Studio，欢迎您的垂问，互联网的产品都会点。（笑 如果不成为程序员，可能会从事设计之类或者文艺行业。（逃 ContactGithub : yingpengsha Email : yingfusheng@foxmail.com QQ : 810998652 Friends呉真 : 关注网络安全、科技前沿，爱研究，爱萝莉，爱折腾，爱外设。 張 : 爱生活，爱科技，爱运维，有时很懒，被高数和英语折磨的死去活来。 soulbiubiubiu : 道破真理，识破真相。 KangChangYi : 有风险，才蜕变。 PinuoC : 保持好奇心。 徐永铭 : 保持愚蠢。 &nbsp;"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-08-31T05:51:31.015Z","comments":true,"path":"archives/index.html","permalink":"https://yingpengsha.github.io/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-08-31T05:51:31.299Z","comments":true,"path":"tags/index.html","permalink":"https://yingpengsha.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-08-31T05:51:31.031Z","comments":false,"path":"categories/index.html","permalink":"https://yingpengsha.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"从this说到call,apply,bind的区别","slug":"从this说到call-apply-bind的区别","date":"2019-05-28T04:54:47.000Z","updated":"2019-05-28T04:58:46.095Z","comments":true,"path":"2019/05/28/从this说到call-apply-bind的区别/","link":"","permalink":"https://yingpengsha.github.io/2019/05/28/从this说到call-apply-bind的区别/","excerpt":"从 this 说到 call，apply，bind 的区别","text":"从 this 说到 call，apply，bind 的区别 this 关键字 this 对象是在运行时基于函数的执行环境绑定的：在全局环境中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。——《Javascript高级程序设计》 借用阮一峰老师的例子来简单阐述一下什么叫做函数的执行环境12345678910var obj = &#123; foo: function() &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 obj.foo() 执行时的指针在 obj 内部，所以该函数的 this 指向了 obj 所在的区域。foo() 执行时指针在全局，所以该函数的 this 指向了全局作用域 箭头函数箭头函数与普通函数有所不同，前者并不是指向运行时上下文，而是定义时上下文。 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined 12345678910var obj = &#123; foo: () =&gt; &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 2foo() // 2 call，apply，bind三个函数的目的是相同的，都是更改函数的 this 指向。 MDN 对这三个函数做了如下定义： call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数。 bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。 call 和 apply 的区别call() 方法的作用和 apply() 方法类似，区别就是 call() 方法接受的是参数列表，而 apply() 方法接受的是一个参数数组。 bind 和 call、apply 的区别bind() 运行后返回一个新函数并不立刻执行，而 call() 和 apply() 则是更改完 this 后立即执行。 参考链接 JavaScript 的 this 原理 this、apply、call、bind Function.prototype.call() Function.prototype.apply() Function.prototype.bind()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"JS的数据类型、类型判断、类型转换","slug":"JS的数据类型、类型判断、类型转换","date":"2019-05-27T12:34:39.000Z","updated":"2019-05-27T12:45:27.029Z","comments":true,"path":"2019/05/27/JS的数据类型、类型判断、类型转换/","link":"","permalink":"https://yingpengsha.github.io/2019/05/27/JS的数据类型、类型判断、类型转换/","excerpt":"数据类型、类型判断、类型转换","text":"数据类型、类型判断、类型转换 JS 的数据类型对我来说一直是一个坑，知识点如果只是背，迟早有一天会忘。所以打算写一篇博客，刨根问底，把它嚼烂了，相信便不会轻易忘记了。PS：写完最后一块，我后脑勺一涨一涨的。 数据类型 基本类型基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。 共有6种基本类型： number ，string ， boolean ， null ， undefined ， symbol (ECMAScript 2015新增)。 所有基本类型的值都是不可改变的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。 Number根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值： +Infinity -Infinity NaN StringJavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。 Boolean布尔表示一个逻辑实体，可以有两个值：true 和 false。 NullNull 类型只有一个值： null，null表示”没有对象”，即该处不应该有值。 Undefined一个没有被赋值的变量会有个默认值 undefined，undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 Symbol符号(Symbols)是ECMAScript 第6版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值. 在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是C里面的枚举类型. 引用类型（对象）引用类型内存放的并非具体的值，而是所对应对象的内存地址。 常用的有引用类型有：Object、Array、Date、RegExp、Function 等 Object一个 Javascript 对象就是键和值之间的映射。键是一个字符串（或者 Symbol） ，值可以是任意类型的值。 Array数组是一种使用整数作为键( integer-key-ed )属性和长度( length )属性之间关联的常规对象。此外，数组对象还继承了 Array.prototype 的一些操作数组的便捷方法。 Date用于存放日期时间的内建对象。 RegExp用于正则表达式的对象。 Function函数是一个附带可被调用功能的常规对象。 类型判断 typeoftypeof操作符返回一个字符串，表示未经计算的操作数的类型。 类型 结果 Number “number” String “string” Boolean “boolean” Null “object” Undefined “undefined” Symbol “symbol” Function “function” 其他引用类型 “object” Null 返回 “object”在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。 New 操作符123456typeof new Boolean(true) === 'object';typeof new Number(1) === 'object';typeof new String(\"abc\") === 'object';// 函数typeof new Function() === 'function'; instanceofinstanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置，适合用于判断自定义的类实例对象, 而不是用来判断原生的数据类型。 123456789101112function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125;var auto = new Car('Honda', 'Accord', 1998);console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true Object.prototype.toStringObject.prototype.toString 之所以能实现类型识别，是因为它可以直接获取 this 的 [[class]] 。 ES5 里如此介绍它的运行过程： 如果 this 的值是 undefined, 返回 “[object Undefined]”. 如果 this 的值是 null, 返回 “[object Null]”. 令 O 为以 this 作为参数调用 ToObject 的结果 . 令 class 为 O 的 [[Class]] 内部属性的值 . 返回三个字符串 “[object “, class, and “]” 连起来的字符串 . 因此我们只需要使用 call / apply 将需要判断的变量绑定到 toString 上的 this 即可。 12Object.prototype.toString.call(null) // [object Null]// 其他类型的变量亦是如此 类型转换 常用类型互相转换参考 基本类型 -&gt; 布尔类型 类型 值 结果 Number 0、-0、NaN false 其他 true String “” false 其他 true Null Null false Undefined Undefined false Symbol / true 基本类型 -&gt; 字符串类型 类型 值 结果 Number / 值 + “” Boolean Null Undefined Symbol / Uncaught TypeError 基本类型 -&gt; 数值类型 类型 值 结果 String 数值字符串 且 只有前后有空格 正常数值 其他（包括：数值字符串，但中间数值中间有空格） NaN Boolean true 1 false 0 Null Null 0 Undefined Undefined NaN Symbol / Uncaught TypeError 基本类型 -&gt; 对象类型 类型 值 结果 Number / 对应构造函数生成的对象 String Boolean Symbol Null {} Undefined 对象类型 -&gt; 基本类型 值 类型 结果 / Number NaN String [object Object] Boolean true Symbol Symbol([object Object]) 数组类型 -&gt; 字符串类型1String([1,2,3]) // \"1,2,3\" == 的类型转换1234null == undefined // true 11 == \"11\" // true 先将字符串转换成数值型再进行比较true == 1 // true == 两边的 true 会变为 1, false 会变为 0[] == 0 // true 暂时没搞懂凸(艹皿艹 ) 转成布尔型了？ + 的类型转换12391 + \"1\" // \"911\" 两边有值，且只要有一个非数值型，则视为字符串连接符。90 + 1 + \"1\"// \"911\" 等于 (90 + 1) + \"1\"+ \"1\" // 1 只有一边有值时，视为数值运算符 其他数学运算符 的类型转换12345// 没有任何余地，全**给我转成数值进行运算new Date('04-02-2018') - '1' // 1522619999999'12' / '6' // 2-'1' // -1 ! 的类型转换1234// 值转成布尔型进行运算!1 // false!!(&#123;&#125;) // true 参考链接 JavaScript 数据类型和数据结构 undefined与null的区别 typeof instanceof ES5 - Object.prototype.toString() JavaScript核心概念(1):类型转换 [译] [1] + [2] - [3] === 9!? 类型转换深入研究","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"HTTP 学习笔记(六): HTTP 状态码","slug":"HTTP学习笔记（六）-HTTP状态码","date":"2019-05-06T04:53:46.000Z","updated":"2019-05-06T04:58:01.481Z","comments":true,"path":"2019/05/06/HTTP学习笔记（六）-HTTP状态码/","link":"","permalink":"https://yingpengsha.github.io/2019/05/06/HTTP学习笔记（六）-HTTP状态码/","excerpt":"","text":"状态码告知从服务器端返回的请求结果状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 状态码如 200 OK，以 3 位数字和原因组成。数字中的第一位指定了响应类别，后两位无分类。响应类别又以下五种 类别 原因短语 1XX Informational（信息性状态码） 收到的请求正在处理中 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX 成功2XX 的响应结果表明请求被正常处理了。 200 OK表示从客户端发来的请求在服务器端被正常处理了。在响应报文里，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分） 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 206 Partial Content该状态码表示客户端进行链范围请求，而服务器成功执行链这部分的 GET 请求。响应报文中包含由 Content-Range 指定返回的实体内容。 3XX 重定向3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签链，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。 1http://example.com/sample 302 Found临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，知识临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。 303 See Other该状态码表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。 304 Not Modified该状态码表示客户端发送附加条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。 4XX 客户端错误4XX 的响应结果表明客户端是发生错误的原因所在。 400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样处理该状态码。 401 Unauthorized该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问 被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问权限，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等例举的情况都可能是发生 403 的原因 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。 500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或默写临时的故障。 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。 状态码和状况不一致不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，但状态码依然返回 200 OK，这种情况也经常遇到。 参考链接 《图解HTTP》","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"HTTP 学习笔记(五): HTTP 报文","slug":"HTTP学习笔记（五）-HTTP报文","date":"2019-05-05T11:23:09.000Z","updated":"2019-05-05T11:39:02.267Z","comments":true,"path":"2019/05/05/HTTP学习笔记（五）-HTTP报文/","link":"","permalink":"https://yingpengsha.github.io/2019/05/05/HTTP学习笔记（五）-HTTP报文/","excerpt":"","text":"HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR + LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR + LF）来划分。通常，并不一定要有报文主体。 报文首部 空行（CR + LF） 报文主体 报文首部：服务器端或客户端需要处理的请求或相应的内容及属性 CR + LF：CR（Carriage Return，回车符：16 进制 0x0d）和 LF（Line Feed，换行符：16 进制 0x0a） 报文主体：应被发送的数据 请求报文 GET / HTTP/1.1 请求行 Host: hackr.jpUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: ja,en-us;q=0.7,en;q=0.3Acceptt-Encoding: gzip, deflateDNT: 1Connection: keep-alivePragma: no-cacheCache-Control: no-cache 各种头部字段 空行（CR + LF） 请求行：请求的方法 + 请求 URI + HTTP 版本 （空格分隔） 首部字段：包含表示请求和响应的各种条件和属性的各类首部。 一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。 响应报文 HTTP/1.1 200 OK 状态行 Date: Fri, 13 Jul 2012 02:45:25 GMTServer: ApacheLast-Modified: Fri, 31 Aug 2007 02:02:20 GMTETag: “45bael-16a-46d776ac”Accept-Ranges: bytesContent-Length: 362Connection: closeContent-Type: text/html 各种头部字段 空行（CR + LF） HTML 内容（PS: MD 没法合理展示） 报文主体 状态行：HTTP版本 + 状态名 + 响应结果（空格分隔） 首部字段：包含表示请求和响应的各种条件和属性的各类首部。 一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。 参考链接 《图解HTTP》","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"HTTP 学习笔记(四): URI、URL、URN","slug":"HTTP学习笔记（四）-URI、URL、URN","date":"2019-05-04T12:13:02.000Z","updated":"2019-05-05T11:22:59.422Z","comments":true,"path":"2019/05/04/HTTP学习笔记（四）-URI、URL、URN/","link":"","permalink":"https://yingpengsha.github.io/2019/05/04/HTTP学习笔记（四）-URI、URL、URN/","excerpt":"","text":"URIURI（Uniform Resource Identifier，统一资源标识符） URI 是使用数字，字母和符号的短字符串来标识文档的标准。 用来唯一表示互联网上的信息资源。 URL 和 URN 都是 URI 的子集。 URLURL（Uniform Resource Locator，统一资源定位符） http:// : 表明是通过什么协议去访问互联网上的某些资源 user:pass : 留给用户认证用，现在很少使用 host.com : 定位资源所在服务器在互联网的位置，ip 或者域名 :80 : 每台服务器有很多端口用于 web 服务，不带端口默认80，为了方便用户记忆一般不带端口 path : 路由，用于找 web 服务里存放的资源，直接对应 web 服务目录结构下的路径 #hash : 定位找到的资源的一个片段 URNURN（Uniform Resource Name，统一资源名称） 唯一标识一个实体的标识符，但是不能给出实体的位置。 urn:isbn:0451450523 以其 ISBN 号码识别一本书。 urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66 全局唯一标识符 urn:publishing:book 使用 XML 命名空间为文档标识一种 book。 参考链接 什么是URI、URL、URN、URC和Data URI？概念及区别 http学习笔记：网络模型&amp;http初识","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"HTTP 学习笔记(三): HTTP 三次握手和四次挥手","slug":"HTTP学习笔记（三）-HTTP三次握手和四次挥手","date":"2019-05-04T11:14:06.000Z","updated":"2019-05-04T11:18:37.517Z","comments":true,"path":"2019/05/04/HTTP学习笔记（三）-HTTP三次握手和四次挥手/","link":"","permalink":"https://yingpengsha.github.io/2019/05/04/HTTP学习笔记（三）-HTTP三次握手和四次挥手/","excerpt":"","text":"引言毫无疑问，HTTP 三次握手和四次挥手在实际应用场景和面试上都属于重点。虽然此前进行过学习，但由于在开发过程中遇到的次数太少，便没有记住多少。为了加强记忆，也为了梳理自身混乱的知识体系，特地记录下来，以便反复学习记忆。 三次握手 seq : sequence SYN : synchronize ACK : acknowledgment SYN_SENT : syn package has been sent SYN_RCVD : syn package has been received 第一次握手Client 发送一个 SYN(seq = x) 包给 Server，然后等待 server 的 ACK 回复，进入SYN-SENT状态。 张三首先向李四招手 (SYN) 第二次握手Server 接收到 SYN(seq = x) 包后就返回一个 ACK(x + 1) 包以及一个自己的 SYN(seq = y) 包，然后等待 Client 的 ACK 回复，Server 进入SYN-RECIVED状态。 李四看到张三向自己招手后，向对方点了点头挤出了一个微笑 (ACK)。但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手 (SYN)。 第三次握手Client 接收到 Server 发回的 ACK(x + 1) 包后，进入ESTABLISHED状态。然后根据 Server 发来的 SYN(seq = y) 包，返回给等待中的 Server 一个 ACK(x + 1) 包。等待中的 Server 收到 ACK 回复，也把自己的状态设置为ESTABLISHED。到此 TCP 三次握手完成，Client 与 Server 可以正常进行通信了。 张三看到李四微笑后确认了李四成功辨认出了自己(进入 ESTALISHED 状态)。张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑 (ACK)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入 ESTALISHED 状态)。 为什么是三次 这个问题在谢希仁版《计算机网络》里说了。三次是保证双方互相明确对方能收能发的最低值。理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。 四次挥手 第一次挥手Initiator 发送一个 FIN(seq = x + 2) + ACK(y + 1) 包，此时 Initiator 进入FIN-WAIT-1状态，这表明Initiator 已经没有数据要发送了。 张三挥手 (FIN) 第二次挥手Recipient 收到了 Initiator 发来的 FIN(seq = x + 2) + ACK(y + 1) 包后，向client发回一个ACK(x + 3)包，此时Recipient 进入CLOSE-WAIT状态，Initiator 进入FIN-WAIT-2状态。 李四伤感地微笑 (ACK) 第三次挥手Recipient 向 Initiator 发送 FIN(seq = y + 1) 包，请求关闭连接，同时 Recipient 进入LAST-ACK状态。 李四挥手 (FIN) 第四次挥手Initiator 收到 Recipient 发送的 FIN(seq = y + 1) 包，进入TIME-WAIT状态。向 Recipient 发送 ACK(y + 2) 包，Recipient 收到client的 ACK(y + 2) 包以后，进入CLOSE状态；Initiator 等待一段时间还没有得到回复后判断Recipient 已正式关闭，进入CLOSE状态。 张三伤感地微笑 (ACK) 为什么是四次 TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，朝张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。 参考链接 图解TCP三次握手与四次分手 跟着动画来学习TCP三次握手和四次挥手 TCP四次挥手简介 TCP 为什么是三次握手，而不是两次或四次？","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"HTTP 学习笔记(二): HTTP协议的发展历史","slug":"HTTP学习笔记（二）-HTTP协议的发展历史","date":"2019-05-04T06:48:05.000Z","updated":"2019-05-04T11:43:49.027Z","comments":true,"path":"2019/05/04/HTTP学习笔记（二）-HTTP协议的发展历史/","link":"","permalink":"https://yingpengsha.github.io/2019/05/04/HTTP学习笔记（二）-HTTP协议的发展历史/","excerpt":"","text":"HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 HTTP / 0.9最早版本是1991年发布的0.9版，该版本极其简单。考古链接 有且只有一个 GET 命令 没有HEADER等描述数据的信息 服务器发送完数据，就关闭TCP连接 请求格式1GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。 响应格式协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; HTTP / 1.01996年5月，HTTP/1.0 版本发布。考古链接 拥有 GET、POST、HEAD 三种命令 增加了 status code 和 header 多字符集支持、多部分发送、权限、缓存、内容编码等 请求格式123GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。 响应格式12345678910HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。 下面是一些常见的Content-Type字段的值。 text/plain text/html text/css image/jpeg image/png image/svg+xml audio/mp4 video/mp4 application/javascript application/pdf application/zip application/atom+xml 这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。除了预定义的类型，厂商也可以自定义类型。 1application/vnd.debian.binary-package 上面的类型表明，发送的是Debian系统的二进制数据包。MIME type还可以在尾部使用分号，添加参数。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。 123&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset=\"utf-8\" /&gt; Content-Encoding 字段由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。 123Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate 缺点HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 1Connection: keep-alive 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。 1Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 HTTP / 1.11997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 支持持久连接 增加了管道机制（pipeline） 支持的命令有：GET、POST、PUT、PATCH、HEAD、OPTIONS、DELETE 请求头支持 Host 字段 持久连接1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭TCP连接。 1Connection: close 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 管道机制1.1 版还引入了管道机制（pipeline），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 Content-Length 字段一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。 1Content-Length: 3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 分块传输编码使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。 1Transfer-Encoding: chunked 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 其他1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。 1Host: www.example.com 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 缺点虽然1.1版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。 HTTP / 22015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。考古链接 所有数据以二进制传输 同一个连接里发送多个请求不再需要按照顺序来 头信息压缩以及推送等提高效率的功能 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 多工HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 参考链接 HTTP 协议发展历史 HTTP协议漫谈 - HTTP协议历史和报文结构","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"HTTP 学习笔记(一): TCP/IP 五层模型","slug":"HTTP学习笔记（一）-经典网络五层模型","date":"2019-05-03T12:13:48.000Z","updated":"2019-05-04T06:49:48.698Z","comments":true,"path":"2019/05/03/HTTP学习笔记（一）-经典网络五层模型/","link":"","permalink":"https://yingpengsha.github.io/2019/05/03/HTTP学习笔记（一）-经典网络五层模型/","excerpt":"","text":"TCP/IP 五层模型应用层( HTTP/FTP )、传输层( TCP/UDP )、网络层、数据链路层、物理层。 应用层 应用层针对特定应用的协议（如，电子邮件协议 E-mail 、远程登录协议 SSH 、文件传输协议 FTP 、网络请求协议 HTTP ） 表示层设备固有的数据格式与网络标准数据格式之间的转换（接受不同的信息，如文字流、图像、声音等） 会话层负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。（何时建立连接？何时断开？以及保持多久的链接） 传输层有了 MAC 地址和 IP 地址，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用（比如实在聊天还是在浏览网页），这个参数就叫”端口”;“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。 网络层引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”（IP地址）。 数据链路层单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号为位有何意义？这就是”链路层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 物理层把电脑连接起来的物理手段，可以用光缆、电缆、双绞线、无线电波等方式，它主要规定了网络的一些电气特征，作用是负责传输0和1的电信号。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"JS 里的数据结构 - 栈","slug":"JS里的数据结构-栈","date":"2019-03-27T06:47:23.000Z","updated":"2019-05-03T12:24:02.789Z","comments":true,"path":"2019/03/27/JS里的数据结构-栈/","link":"","permalink":"https://yingpengsha.github.io/2019/03/27/JS里的数据结构-栈/","excerpt":"","text":"开篇语未来将会结合《学习 JavaScript 数据结构和算法》这本书写一系列的算法笔记。之所以想要深入学习算法的原因，是前段时间阿里的校招让我打击很大，自信心受到了强烈的冲击。但好在我是一个从来不怕低谷的人，也十分庆幸在很早的时间点里受到迟早该受到的挫折。 逝者如斯，故不舍昼夜。 栈栈数据结构栈是一种遵循后进先出( LIFO )原理的有序集合。新添的或待删除的元素都保存在栈的同一段，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 JavaScript 里的 Stack 类创建一个 Stack 类的构造函数123function Stack()&#123; // 各种属性和方法的声明&#125; 需要一种数据结构来保存栈里的元素1234function Stack()&#123; let items = []; // 各种属性和方法的声明&#125; 向栈里添加元素添加一个 push 方法123456function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125;&#125; 从栈里删除元素添加一个 pop 方法123456789function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125;&#125; 查看栈顶元素添加一个 peek 方法123456789101112function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125;&#125; 检查栈是否为空添加一个 isEmpty 方法123456789101112131415function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125;&#125; 清空栈的内容添加一个 clear 方法123456789101112131415161718function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125;&#125; 打印栈的内容添加一个 print 方法123456789101112131415161718192021function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125;&#125; 输出栈的元素数量添加一个 size 方法123456789101112131415161718192021222324function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125; this.size = function()&#123; console.log(items.length); &#125;&#125; 使用 Stack 类123456789101112131415161718192021222324252627282930function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125; this.size = function()&#123; console.log(items.length); &#125;&#125;let stack = new Stack();stack.push('one');stack.print(); // onestack.size(); // 1console.log(stack.peek()); // one","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"数组的常用方法","slug":"数组的常用方法","date":"2019-03-25T13:15:10.000Z","updated":"2019-05-03T12:25:09.030Z","comments":true,"path":"2019/03/25/数组的常用方法/","link":"","permalink":"https://yingpengsha.github.io/2019/03/25/数组的常用方法/","excerpt":"数组的常用方法","text":"数组的常用方法 创建和初始化数组使用 Array 构造函数初始化123let array1 = new Array();let array2 = new Array(7);let array3 = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'); 直接赋值创建12let array1 = [];let array2 = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; Array.of 方法Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。12let array1 = Array.of(7); // [7]let array2 = Array.of(...[1, 2, 3, 4]); // [1, 2, 3, 4] 二维和多维数组二维数组123let matrixArray = new Array(2);matrixArray[0] = new Array('0.0', '0.1', '0.2', '0.3');matrixArray[1] = new Array('1.0', '1.1', '1.2', '1.3'); - [0] [1] [2] [3] [0] ‘0.0’ ‘0.1’ ‘0.2’ ‘0.3’ [1] ‘1.0’ ‘1.1’ ‘1.2’ ‘1.3’ 搜索元素使用 indexOf 方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。123let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.indexOf(10)) // 9console.log(array.indexOf('A')) // -1 使用 lastIndexOf 方法lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。12345let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.lastIndexOf(10)) // 10console.log(array.indexOf('A')) // -1console.log(array.lastIndexOf(10, 9)) // 9 使用 find 方法find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。123456789let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];let find1 = array.find((value, index, arr) =&gt; &#123; return value % 2 === 0;&#125;) // 2let find2 = array.find((value, index, arr) =&gt; &#123; return typeof value === 'string';&#125;) // undefined 使用 findIndex 方法findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。123456789let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];let find1 = array.findIndex((value, index, arr) =&gt; &#123; return value % 2 === 0;&#125;) // 1let find2 = array.findIndex((value, index, arr) =&gt; &#123; return typeof value === 'string';&#125;) // -1 使用 includes 方法includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。123let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.includes(10)) // trueconsole.log(array.includes('A')) // false 添加元素使用 push 方法push 方法，能把任意元素添加到数组的末尾。12let array = [1, 2, 3];array.push('number'); //[1, 2, 3, 'number'] 使用 unshfit 方法unshfit 方法，能把任意元素添加至数组的开头。 12let array = [1, 2, 3];array.unshfit('number1', 'number2'); // ['number1', 'number2', 1, 2, 3] 删除元素使用 pop 方法pop 方法，能在数组的末尾删除一个元素。12let array = [1, 2, 3, 'number'];array.pop(); // [1, 2, 3] 使用 shfit 方法shfit方法，能在数组的开头删除一个元素。12let array = [ 'number', 1, 2, 3];array.shfit(); // [1, 2, 3] 在任意位置删除、添加、替换元素使用 splice 删除元素12let array = [1, 2, 3, 4, 5];array.splice(0, 3); // [4, 5]; 使用 splice 添加元素123let array = [1, 2, 3];let insertArray = ['number1', 'number2']array.splice(1, 0, ...insertArray); // [1, 'number1', 'number2', 2, 3]; 使用 splice 替换元素123let array = [1, 2, 3];let replaceArray = ['number1', 'number2']array.splice(1, 1, ...replaceArray); // [1, 'number1', 'number2', 3]; 使用 fill 替换元素fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。123let array = [1, 2, 3];let number = 0;array.fill(number, 1, 3); // [1, 0, 0] 数组合并使用 concat 连接数组concat 函数并不会直接改变数组的值，而是返回一个连接后的数组123let array1 = [1, 2, 3];let array2 = ['a', 'b', 'c'];let result = array1.concat(array2); // [1, 2, 3, 'a', 'b', 'c'] 排序元素使用 sort 方法排序12let array = [5, 3, 2, 1, 4];array.sort(); // [1, 2, 3, 4, 5] 使用 sort 方法自定义排序12345678910111213let array = ['D', 'a', 'c', 'B'];array.sort(); // ['B', 'D', 'a', 'c']let strCompare = (one, two) =&gt; &#123; if (one.toLowerCase() &lt; b.toLowerCase()) &#123; return -1; &#125; if (one.toLowerCase() &gt; b.toLowerCase()) &#123; return 1; &#125; return 0;&#125;array.sort(strCompare); // ['a', 'B', 'c' 'D'] 使用 reverse 方法将数组中元素的位置颠倒12let array = [1, 2, 3, 4, 5];array.reverse(); // [5, 4, 3, 2, 1] 迭代器函数forEach 方法forEach( ) 方法对数组的每个元素执行一次提供的函数。12345678let array = [1, 2, 3, 4];array.forEach((value, index, arr) =&gt; &#123; console.log(value % 2 === 0); // 输入出是否被 2 整除&#125;)// false// true// false// true for …… of 循环迭代12345678let array = [1, 2, 3, 4];for (const number of array) &#123; console.log(n % 2 === 0)&#125;// false// true// false// true map 方法map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。123456let array = [1, 2, 3, 4];let result = array.forEach((value, index, arr) =&gt; &#123; return value * 2;&#125;)// array : [1, 2, 3, 4]// result : [2, 4, 6, 8] filter 方法filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。123456let array = [1, 2, 3, 4];let result = array.filter((value, index, arr) =&gt; &#123; return value &gt; 2;&#125;)// array : [1, 2, 3, 4]// result : [3, 4] reduce 方法reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。12345let array = [1, 2, 3, 4];let result = array.reduce((value, currentValue, index, arr) =&gt; &#123; return value + currentValue;&#125;, 5)// result : 5 + 1 + 2 + 3 + 4 = 15 every 方法every( )方法测试数组的所有元素是否都通过了指定函数的测试。1234567891011let array = [1, 2, 3, 4];array.every((value) =&gt; &#123; return value % 2 === 0; // 数组是否都能被 2 整除&#125;)// falsearray.every((value) =&gt; &#123; return typeof value == 'number'; // 数组是否都是数字&#125;)// true some 方法some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。1234567891011let array = [1, 2, 3, 4];array.some((value) =&gt; &#123; return value % 2 === 0; // 数组有没有能被 2 整除的值&#125;)// truearray.some((value) =&gt; &#123; return typeof value == 'string'; // 数组有没有字符串&#125;)// false entries 方法entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。12345678let array = [1, 2, 3, 4];let iterator = array.entries();console.log(iterator.next()); // &#123;value: [0, 1], done: false &#125;console.log(iterator.next()); // &#123;value: [1, 2], done: false &#125;console.log(iterator.next()); // &#123;value: [2, 3], done: false &#125;console.log(iterator.next()); // &#123;value: [3, 4], done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; keys 方法keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。12345678let array = [1, 2, 3, 4];let iterator = array.keys();console.log(iterator.next()); // &#123;value: 0, done: false &#125;console.log(iterator.next()); // &#123;value: 1, done: false &#125;console.log(iterator.next()); // &#123;value: 2, done: false &#125;console.log(iterator.next()); // &#123;value: 3, done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; values 方法values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值12345678let array = [1, 2, 3, 4];let iterator = array.values();console.log(iterator.next()); // &#123;value: 1, done: false &#125;console.log(iterator.next()); // &#123;value: 2, done: false &#125;console.log(iterator.next()); // &#123;value: 3, done: false &#125;console.log(iterator.next()); // &#123;value: 4, done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; Array.from 方法Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。12console.log(Array.from('number')); // ['n', 'u', 'm', 'b', 'e', 'r']console.log(Array.from([1, 2, 3], value =&gt; value + 1)); // [2, 3, 4] 输出数组为字符串toString 方法12let array = ['h', 'e', 'l', 'l', 'o'];console.log(array.toString()); // 'h, e, l, l, o' join 方法12let array = ['h', 'e', 'l', 'l', 'o'];console.log(array.join('-')); // 'h-e-l-l-o'","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"重新开始","slug":"重新开始","date":"2019-03-20T11:26:51.000Z","updated":"2019-03-20T12:35:00.312Z","comments":true,"path":"2019/03/20/重新开始/","link":"","permalink":"https://yingpengsha.github.io/2019/03/20/重新开始/","excerpt":"&emsp;&emsp;早在一个星期前，刷微博刷到阿里春招开始，心思仿佛春天里的花朵一样开始疯狂生长。马上吃完饭，跑回432，激动地打开电脑，制作简历，寻求内推，直接投递，一气呵成堪称猴急中的猴急。那时候爱幻想的我都开始幻想实习的生活了（大笑","text":"&emsp;&emsp;早在一个星期前，刷微博刷到阿里春招开始，心思仿佛春天里的花朵一样开始疯狂生长。马上吃完饭，跑回432，激动地打开电脑，制作简历，寻求内推，直接投递，一气呵成堪称猴急中的猴急。那时候爱幻想的我都开始幻想实习的生活了（大笑 &emsp;&emsp;第一通电话是在投完简历后的第二天，中间的那一天我在做测试题，测试题挺有意思的。 &emsp;&emsp;电话内容很简单，请问第二天有没有时间进行面试。 &emsp;&emsp;当然有，必须有。 &emsp;&emsp;确定有时间后便嘟嘟挂掉了 &emsp;&emsp;接完电话后心情难以平复，这次算是人生第一份简历的回应？第一次总是难以言喻的，更何况是阿里的反应。 &emsp;&emsp;后面的半天便开始找面试题，开始复习，发现内容还算简单，都是学过的东西，只是有些遗忘，还有就是知识有点琐碎，尤其麻烦的是口述起来很难讲清楚。 &emsp;&emsp;后面的故事大概就是，反复练习口述知识点，然后等到第二天天亮，紧张的接到电话，开始面试。 &emsp;&emsp;面试时间长达36分钟，还算可以，和面试官谈笑风声（也许？，总体来说还算积极。 &emsp;&emsp;在面试结束的时候，面试官问下午有没有时间编程题，那时有点吃惊，进度也太快了吧，虽然吃惊但还是应承下来。 &emsp;&emsp;等到下午，有点精神疲惫的开始等待邮件，本来说好去午睡硬是没睡成。 &emsp;&emsp;中间换了一个编程网站后正式开始测试。 &emsp;&emsp;题目很难，虽然有各种因素在里面，但客观来说对我来说很难，面试官很好，一直在引导我，但似乎我有点笨，他的引导让我想的越来越复杂，直到崩溃的结束了这场让我铭记的测试。 总结&emsp;&emsp;过程大概是这样，最后的编程题，实在是打击太大，事后我自己都不相信我敲出了这么蠢的代码。 &emsp;&emsp;这次面试收获还是很丰富的，首当其冲的是戳破了膨胀的心，本以为自己多少还有点实力，结果发现其实差的还很远。 &emsp;&emsp;后面得了流感，迎来了落魄的四五天。 &emsp;&emsp;立了很多目标，秋天的时候我会再来的。 &emsp;&emsp;“黄沙百战穿金甲，不破楼兰终不还”","categories":[{"name":"生活","slug":"生活","permalink":"https://yingpengsha.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://yingpengsha.github.io/tags/生活/"}]},{"title":"顾城谈薛宝钗：无求无喜，一切有度","slug":"顾城谈薛宝钗：-无求无喜，一切有度","date":"2018-08-31T06:14:55.000Z","updated":"2019-03-20T12:16:06.656Z","comments":true,"path":"2018/08/31/顾城谈薛宝钗：-无求无喜，一切有度/","link":"","permalink":"https://yingpengsha.github.io/2018/08/31/顾城谈薛宝钗：-无求无喜，一切有度/","excerpt":"&emsp;&emsp;林黛玉心性之强，达到女儿的顶点。她知道湘云、探春都不如她，至于宝琴，更是视之若无，所以很好；但对于宝钗一直心怀恐惧，这个恐惧是一种对于未知的恐惧，她无法明白宝钗的心之所在。宝钗生为女儿身，却并无多少女儿性。","text":"&emsp;&emsp;林黛玉心性之强，达到女儿的顶点。她知道湘云、探春都不如她，至于宝琴，更是视之若无，所以很好；但对于宝钗一直心怀恐惧，这个恐惧是一种对于未知的恐惧，她无法明白宝钗的心之所在。宝钗生为女儿身，却并无多少女儿性。 &emsp;&emsp;林黛玉不会嫉妒袭人，但是她较上了宝钗。真性情之间的关系并不都是友好，经常是非常残酷的。 &emsp;&emsp;宝钗的空和宝玉有所不同，她空而无我，她知道生活毫无意义，所以不会执留，也不会为失败而伤心；但是她又知道这就是全部的意义，所以做一点女红，或安慰母亲，照顾别人。她知道空无，却不会像宝玉一样移情于空无，因为她生性平和，空到了无情可移。她永远不会出家，死，或称为神秘主义者，那都是自怜自艾之人的道路。她会生活下去，成为生活本身。​ &emsp;&emsp;她与生活唯一的不同，是她还看得到虚空和走进虚空的人看见的幻影。也只有她，听清了宝玉最后的不祥之言。 &emsp;&emsp;宝钗无妄想，亦无理想，亦不会破灭，又啥都明白，自可过太平日子。 &emsp;&emsp;她无求无喜，却一切有度，不是无可奈何的折中，确是一种天然的“合适”。这“合适”的法则举世无例，所以也不拘泥。所做大体是公正，名分上的事情自去做，但也无私。对针尖麦芒的黛玉她意外爱护，赠诗送药。小心眼的人读此多以为是她笼络伎俩，其实不然。宝钗还是知人品性，清浊。她看黛玉倒是较宝玉为重。其实她又何尝看得上宝玉。 &emsp;&emsp;薛宝钗根本的体现了中国哲学的另外一个方面，她的屋子里一片雪白，什么都没有。实际上她是最早悟到这白茫茫大地真干净的人了。她不是通过痛苦和思考悟到的，而是天性如此。家里破产，哥哥被抓了，趁有活口，劝她妈妈问问他还欠了别人多少钱，都没钱了，她也无所谓。她是真正无所谓的人，可是她一切事都做，一切都要做的合适。她不求目的，只有合适，这就是中庸之道。这种合适又很微妙：这个人应对这个事，它合适；他们俩之间这样做合适，它是随机应变的，又是先验的。这个合适蕴涵在她的所有内里外在中间。实际上她根本看不上贾宝玉，但她也无所谓。 &emsp;&emsp;她是无所求的人，所以你不能以市俗经验推想她的动机，为什么要什么，她就像“月映万川”，只是现象罢了。 &emsp;&emsp;薛宝钗天然的悟，有一事可以说明。贾宝玉早先看戏，鲁智深有句唱词说“赤条条来去无牵挂”。当即宝玉就落下泪来，黛玉就吃了一惊。宝钗于是说：“坏了，这个人悟了”黛玉说：“哪的事啊，看我问他一问。”黛玉就问了他两句话，宝玉一呆就答不上来，也就不想这件事了。这是他第一次感觉到世界与自己没有关系。那么实际上，宝钗说“坏了”的时候，就已经在前面等着他了。 &emsp;&emsp;中国只有两次描画了人间的天国，一个是陶渊明的桃花源，一个是红楼梦的大观园。 ​&emsp;&emsp;在《红楼梦》里，人无论好坏，只论清浊，其中的女儿性恰恰体现了中国人对于人性和谐的最高梦想。男性化的醒悟往往在于领悟自身的虚幻，将人归于天。而女儿是水做的，无须这种领悟，她们是天化的人，自身就是天上无尘的花朵，在显示冥冥之时，上天也不能不欣赏自己的创作。 ​&emsp;&emsp;我认为《红楼梦》之所以这么漂亮，不在于它仅仅是写好了一个什么故事，或表达了哲学观念，而在于它体现出中国精神一个特别美妙的地方。 ​&emsp;&emsp;这个美妙的部分在西方文学里本来是个绝望的部分，就是浮士德说的“真美呵，你停下来吧”，但是就消失了的那个部分。它不停下来，因为执之者失。这时中国就采取一个什么办法呢？——此时无声胜有声，此处相望不相闻。 ​&emsp;&emsp;任万物自生，如天观世。每个生命的美丽都不去驾驭，自现而自隐，自灭而自生。黛玉和宝玉，爱的那么深切，也没有说，我爱你，一点也没有。它就是两个心的显示过程。","categories":[{"name":"文学","slug":"文学","permalink":"https://yingpengsha.github.io/categories/文学/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://yingpengsha.github.io/tags/文学/"}]}]}