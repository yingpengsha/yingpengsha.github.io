{"meta":{"title":"YINGPENGSHA","subtitle":"coder","description":"Pease & Love","author":"YINGPENGSHA","url":"https://yingpengsha.github.io"},"pages":[{"title":"","date":"2018-08-31T06:33:37.744Z","updated":"2018-08-31T06:33:37.744Z","comments":true,"path":"404.html","permalink":"https://yingpengsha.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2018-08-31T07:47:23.734Z","updated":"2018-08-31T07:47:23.734Z","comments":true,"path":"README.html","permalink":"https://yingpengsha.github.io/README.html","excerpt":"","text":"yingpengsha’s blogHi, this is yingpengsha’s blog. You can click here(https://yingpengsha.github.io) to visit."},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2019-03-26T04:52:52.540Z","comments":true,"path":"about/index.html","permalink":"https://yingpengsha.github.io/about/index.html","excerpt":"","text":"AboutMe你好，我是 yingpengsha，自我意识旺盛所以没有合适的网名。 就读于 绍兴文理学院 绍兴大学，现在 大一大二 大三。 可能会成为程序员，从事前端（正在学习机器学习中），擅长ECMAScript 6、Typescript、React.js、React-Native、Vue.js。 有个工作室FEARLESS Studio，欢迎您的垂问，互联网的产品都会点。（笑 如果不成为程序员，可能会从事设计之类或者文艺行业。（逃 ContactGithub : yingpengsha Email : yingfusheng@foxmail.com QQ : 810998652 Friends呉真 : 关注网络安全、科技前沿，爱研究，爱萝莉，爱折腾，爱外设。 張 : 爱生活，爱科技，爱运维，有时很懒，被高数和英语折磨的死去活来。 soulbiubiubiu : 道破真理，识破真相。 KangChangYi : 有风险，才蜕变。 PinuoC : 保持好奇心。 徐永铭 : 保持愚蠢。 &nbsp;"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-08-31T05:51:31.031Z","comments":false,"path":"categories/index.html","permalink":"https://yingpengsha.github.io/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-08-31T05:51:31.015Z","comments":true,"path":"archives/index.html","permalink":"https://yingpengsha.github.io/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-08-31T05:51:31.299Z","comments":true,"path":"tags/index.html","permalink":"https://yingpengsha.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP 学习笔记(一): TCP/IP 五层模型","slug":"HTTP学习笔记（一）-经典网络五层模型","date":"2019-05-03T12:13:48.000Z","updated":"2019-05-03T12:21:14.268Z","comments":true,"path":"2019/05/03/HTTP学习笔记（一）-经典网络五层模型/","link":"","permalink":"https://yingpengsha.github.io/2019/05/03/HTTP学习笔记（一）-经典网络五层模型/","excerpt":"","text":"HTTP 学习笔记（一）：TCP/IP 五层模型 TCP/IP 五层模型应用层( HTTP/FTP )、传输层( TCP/UDP )、网络层、数据链路层、物理层。 应用层 应用层针对特定应用的协议（如，电子邮件协议 E-mail 、远程登录协议 SSH 、文件传输协议 FTP 、网络请求协议 HTTP ） 表示层设备固有的数据格式与网络标准数据格式之间的转换（接受不同的信息，如文字流、图像、声音等） 会话层负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。（何时建立连接？何时断开？以及保持多久的链接） 传输层有了 MAC 地址和 IP 地址，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用（比如实在聊天还是在浏览网页），这个参数就叫”端口”;“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。 网络层引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”（IP地址）。 数据链路层单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号为位有何意义？这就是”链路层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 物理层把电脑连接起来的物理手段，可以用光缆、电缆、双绞线、无线电波等方式，它主要规定了网络的一些电气特征，作用是负责传输0和1的电信号。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://yingpengsha.github.io/tags/HTTP/"}]},{"title":"JS 里的数据结构 - 栈","slug":"JS里的数据结构-栈","date":"2019-03-27T06:47:23.000Z","updated":"2019-03-27T12:53:29.511Z","comments":true,"path":"2019/03/27/JS里的数据结构-栈/","link":"","permalink":"https://yingpengsha.github.io/2019/03/27/JS里的数据结构-栈/","excerpt":"","text":"开篇语未来将会结合《学习 JavaScript 数据结构和算法》这本书写一系列的算法笔记。之所以想要深入学习算法的原因，是前段时间阿里的校招让我打击很大，自信心受到了强烈的冲击。但好在我是一个从来不怕低谷的人，也十分庆幸在很早的时间点里受到迟早该受到的挫折。 逝者如斯，故不舍昼夜。 栈栈数据结构栈是一种遵循后进先出( LIFO )原理的有序集合。新添的或待删除的元素都保存在栈的同一段，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 JavaScript 里的 Stack 类创建一个 Stack 类的构造函数123function Stack()&#123; // 各种属性和方法的声明&#125; 需要一种数据结构来保存栈里的元素1234function Stack()&#123; let items = []; // 各种属性和方法的声明&#125; 向栈里添加元素添加一个 push 方法123456function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125;&#125; 从栈里删除元素添加一个 pop 方法123456789function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125;&#125; 查看栈顶元素添加一个 peek 方法123456789101112function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125;&#125; 检查栈是否为空添加一个 isEmpty 方法123456789101112131415function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125;&#125; 清空栈的内容添加一个 clear 方法123456789101112131415161718function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125;&#125; 打印栈的内容添加一个 print 方法123456789101112131415161718192021function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125;&#125; 输出栈的元素数量添加一个 size 方法123456789101112131415161718192021222324function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125; this.size = function()&#123; console.log(items.length); &#125;&#125; 使用 Stack 类123456789101112131415161718192021222324252627282930function Stack()&#123; let items = []; this.push = function(item)&#123; items.push(item); &#125; this.pop = function(item)&#123; items.pop(item); &#125; this.peek = function()&#123; return items[items.length - 1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(items.toString()); &#125; this.size = function()&#123; console.log(items.length); &#125;&#125;let stack = new Stack();stack.push(&apos;one&apos;);stack.print(); // onestack.size(); // 1console.log(stack.peek()); // one","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"数组的常用方法","slug":"数组的常用方法","date":"2019-03-25T13:15:10.000Z","updated":"2019-03-27T06:46:41.171Z","comments":true,"path":"2019/03/25/数组的常用方法/","link":"","permalink":"https://yingpengsha.github.io/2019/03/25/数组的常用方法/","excerpt":"数组的常用方法","text":"数组的常用方法 创建和初始化数组使用 Array 构造函数初始化123let array1 = new Array();let array2 = new Array(7);let array3 = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); 直接赋值创建12let array1 = [];let array2 = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; Array.of 方法Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。12let array1 = Array.of(7); // [7]let array2 = Array.of(...[1, 2, 3, 4]); // [1, 2, 3, 4] 二维和多维数组二维数组123let matrixArray = new Array(2);matrixArray[0] = new Array(&apos;0.0&apos;, &apos;0.1&apos;, &apos;0.2&apos;, &apos;0.3&apos;);matrixArray[1] = new Array(&apos;1.0&apos;, &apos;1.1&apos;, &apos;1.2&apos;, &apos;1.3&apos;); - [0] [1] [2] [3] [0] ‘0.0’ ‘0.1’ ‘0.2’ ‘0.3’ [1] ‘1.0’ ‘1.1’ ‘1.2’ ‘1.3’ 搜索元素使用 indexOf 方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。123let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.indexOf(10)) // 9console.log(array.indexOf(&apos;A&apos;)) // -1 使用 lastIndexOf 方法lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。12345let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.lastIndexOf(10)) // 10console.log(array.indexOf(&apos;A&apos;)) // -1console.log(array.lastIndexOf(10, 9)) // 9 使用 find 方法find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。123456789let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];let find1 = array.find((value, index, arr) =&gt; &#123; return value % 2 === 0;&#125;) // 2let find2 = array.find((value, index, arr) =&gt; &#123; return typeof value === &apos;string&apos;;&#125;) // undefined 使用 findIndex 方法findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。123456789let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];let find1 = array.findIndex((value, index, arr) =&gt; &#123; return value % 2 === 0;&#125;) // 1let find2 = array.findIndex((value, index, arr) =&gt; &#123; return typeof value === &apos;string&apos;;&#125;) // -1 使用 includes 方法includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。123let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10];console.log(array.includes(10)) // trueconsole.log(array.includes(&apos;A&apos;)) // false 添加元素使用 push 方法push 方法，能把任意元素添加到数组的末尾。12let array = [1, 2, 3];array.push(&apos;number&apos;); //[1, 2, 3, &apos;number&apos;] 使用 unshfit 方法unshfit 方法，能把任意元素添加至数组的开头。 12let array = [1, 2, 3];array.unshfit(&apos;number1&apos;, &apos;number2&apos;); // [&apos;number1&apos;, &apos;number2&apos;, 1, 2, 3] 删除元素使用 pop 方法pop 方法，能在数组的末尾删除一个元素。12let array = [1, 2, 3, &apos;number&apos;];array.pop(); // [1, 2, 3] 使用 shfit 方法shfit方法，能在数组的开头删除一个元素。12let array = [ &apos;number&apos;, 1, 2, 3];array.shfit(); // [1, 2, 3] 在任意位置删除、添加、替换元素使用 splice 删除元素12let array = [1, 2, 3, 4, 5];array.splice(0, 3); // [4, 5]; 使用 splice 添加元素123let array = [1, 2, 3];let insertArray = [&apos;number1&apos;, &apos;number2&apos;]array.splice(1, 0, ...insertArray); // [1, &apos;number1&apos;, &apos;number2&apos;, 2, 3]; 使用 splice 替换元素123let array = [1, 2, 3];let replaceArray = [&apos;number1&apos;, &apos;number2&apos;]array.splice(1, 1, ...replaceArray); // [1, &apos;number1&apos;, &apos;number2&apos;, 3]; 使用 fill 替换元素fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。123let array = [1, 2, 3];let number = 0;array.fill(number, 1, 3); // [1, 0, 0] 数组合并使用 concat 连接数组concat 函数并不会直接改变数组的值，而是返回一个连接后的数组123let array1 = [1, 2, 3];let array2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];let result = array1.concat(array2); // [1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 排序元素使用 sort 方法排序12let array = [5, 3, 2, 1, 4];array.sort(); // [1, 2, 3, 4, 5] 使用 sort 方法自定义排序12345678910111213let array = [&apos;D&apos;, &apos;a&apos;, &apos;c&apos;, &apos;B&apos;];array.sort(); // [&apos;B&apos;, &apos;D&apos;, &apos;a&apos;, &apos;c&apos;]let strCompare = (one, two) =&gt; &#123; if (one.toLowerCase() &lt; b.toLowerCase()) &#123; return -1; &#125; if (one.toLowerCase() &gt; b.toLowerCase()) &#123; return 1; &#125; return 0;&#125;array.sort(strCompare); // [&apos;a&apos;, &apos;B&apos;, &apos;c&apos; &apos;D&apos;] 使用 reverse 方法将数组中元素的位置颠倒12let array = [1, 2, 3, 4, 5];array.reverse(); // [5, 4, 3, 2, 1] 迭代器函数forEach 方法forEach( ) 方法对数组的每个元素执行一次提供的函数。12345678let array = [1, 2, 3, 4];array.forEach((value, index, arr) =&gt; &#123; console.log(value % 2 === 0); // 输入出是否被 2 整除&#125;)// false// true// false// true for …… of 循环迭代12345678let array = [1, 2, 3, 4];for (const number of array) &#123; console.log(n % 2 === 0)&#125;// false// true// false// true map 方法map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。123456let array = [1, 2, 3, 4];let result = array.forEach((value, index, arr) =&gt; &#123; return value * 2;&#125;)// array : [1, 2, 3, 4]// result : [2, 4, 6, 8] filter 方法filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。123456let array = [1, 2, 3, 4];let result = array.filter((value, index, arr) =&gt; &#123; return value &gt; 2;&#125;)// array : [1, 2, 3, 4]// result : [3, 4] reduce 方法reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。12345let array = [1, 2, 3, 4];let result = array.reduce((value, currentValue, index, arr) =&gt; &#123; return value + currentValue;&#125;, 5)// result : 5 + 1 + 2 + 3 + 4 = 15 every 方法every( )方法测试数组的所有元素是否都通过了指定函数的测试。1234567891011let array = [1, 2, 3, 4];array.every((value) =&gt; &#123; return value % 2 === 0; // 数组是否都能被 2 整除&#125;)// falsearray.every((value) =&gt; &#123; return typeof value == &apos;number&apos;; // 数组是否都是数字&#125;)// true some 方法some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。1234567891011let array = [1, 2, 3, 4];array.some((value) =&gt; &#123; return value % 2 === 0; // 数组有没有能被 2 整除的值&#125;)// truearray.some((value) =&gt; &#123; return typeof value == &apos;string&apos;; // 数组有没有字符串&#125;)// false entries 方法entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。12345678let array = [1, 2, 3, 4];let iterator = array.entries();console.log(iterator.next()); // &#123;value: [0, 1], done: false &#125;console.log(iterator.next()); // &#123;value: [1, 2], done: false &#125;console.log(iterator.next()); // &#123;value: [2, 3], done: false &#125;console.log(iterator.next()); // &#123;value: [3, 4], done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; keys 方法keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。12345678let array = [1, 2, 3, 4];let iterator = array.keys();console.log(iterator.next()); // &#123;value: 0, done: false &#125;console.log(iterator.next()); // &#123;value: 1, done: false &#125;console.log(iterator.next()); // &#123;value: 2, done: false &#125;console.log(iterator.next()); // &#123;value: 3, done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; values 方法values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值12345678let array = [1, 2, 3, 4];let iterator = array.values();console.log(iterator.next()); // &#123;value: 1, done: false &#125;console.log(iterator.next()); // &#123;value: 2, done: false &#125;console.log(iterator.next()); // &#123;value: 3, done: false &#125;console.log(iterator.next()); // &#123;value: 4, done: false &#125;console.log(iterator.next()); // &#123;value: undefined, done: true &#125; Array.from 方法Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。12console.log(Array.from(&apos;number&apos;)); // [&apos;n&apos;, &apos;u&apos;, &apos;m&apos;, &apos;b&apos;, &apos;e&apos;, &apos;r&apos;]console.log(Array.from([1, 2, 3], value =&gt; value + 1)); // [2, 3, 4] 输出数组为字符串toString 方法12let array = [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;];console.log(array.toString()); // &apos;h, e, l, l, o&apos; join 方法12let array = [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;];console.log(array.join(&apos;-&apos;)); // &apos;h-e-l-l-o&apos;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://yingpengsha.github.io/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yingpengsha.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://yingpengsha.github.io/tags/ECMAScript/"}]},{"title":"重新开始","slug":"重新开始","date":"2019-03-20T11:26:51.000Z","updated":"2019-03-20T12:35:00.312Z","comments":true,"path":"2019/03/20/重新开始/","link":"","permalink":"https://yingpengsha.github.io/2019/03/20/重新开始/","excerpt":"&emsp;&emsp;早在一个星期前，刷微博刷到阿里春招开始，心思仿佛春天里的花朵一样开始疯狂生长。马上吃完饭，跑回432，激动地打开电脑，制作简历，寻求内推，直接投递，一气呵成堪称猴急中的猴急。那时候爱幻想的我都开始幻想实习的生活了（大笑","text":"&emsp;&emsp;早在一个星期前，刷微博刷到阿里春招开始，心思仿佛春天里的花朵一样开始疯狂生长。马上吃完饭，跑回432，激动地打开电脑，制作简历，寻求内推，直接投递，一气呵成堪称猴急中的猴急。那时候爱幻想的我都开始幻想实习的生活了（大笑 &emsp;&emsp;第一通电话是在投完简历后的第二天，中间的那一天我在做测试题，测试题挺有意思的。 &emsp;&emsp;电话内容很简单，请问第二天有没有时间进行面试。 &emsp;&emsp;当然有，必须有。 &emsp;&emsp;确定有时间后便嘟嘟挂掉了 &emsp;&emsp;接完电话后心情难以平复，这次算是人生第一份简历的回应？第一次总是难以言喻的，更何况是阿里的反应。 &emsp;&emsp;后面的半天便开始找面试题，开始复习，发现内容还算简单，都是学过的东西，只是有些遗忘，还有就是知识有点琐碎，尤其麻烦的是口述起来很难讲清楚。 &emsp;&emsp;后面的故事大概就是，反复练习口述知识点，然后等到第二天天亮，紧张的接到电话，开始面试。 &emsp;&emsp;面试时间长达36分钟，还算可以，和面试官谈笑风声（也许？，总体来说还算积极。 &emsp;&emsp;在面试结束的时候，面试官问下午有没有时间编程题，那时有点吃惊，进度也太快了吧，虽然吃惊但还是应承下来。 &emsp;&emsp;等到下午，有点精神疲惫的开始等待邮件，本来说好去午睡硬是没睡成。 &emsp;&emsp;中间换了一个编程网站后正式开始测试。 &emsp;&emsp;题目很难，虽然有各种因素在里面，但客观来说对我来说很难，面试官很好，一直在引导我，但似乎我有点笨，他的引导让我想的越来越复杂，直到崩溃的结束了这场让我铭记的测试。 总结&emsp;&emsp;过程大概是这样，最后的编程题，实在是打击太大，事后我自己都不相信我敲出了这么蠢的代码。 &emsp;&emsp;这次面试收获还是很丰富的，首当其冲的是戳破了膨胀的心，本以为自己多少还有点实力，结果发现其实差的还很远。 &emsp;&emsp;后面得了流感，迎来了落魄的四五天。 &emsp;&emsp;立了很多目标，秋天的时候我会再来的。 &emsp;&emsp;“黄沙百战穿金甲，不破楼兰终不还”","categories":[{"name":"生活","slug":"生活","permalink":"https://yingpengsha.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://yingpengsha.github.io/tags/生活/"}]},{"title":"顾城谈薛宝钗：无求无喜，一切有度","slug":"顾城谈薛宝钗：-无求无喜，一切有度","date":"2018-08-31T06:14:55.000Z","updated":"2019-03-20T12:16:06.656Z","comments":true,"path":"2018/08/31/顾城谈薛宝钗：-无求无喜，一切有度/","link":"","permalink":"https://yingpengsha.github.io/2018/08/31/顾城谈薛宝钗：-无求无喜，一切有度/","excerpt":"&emsp;&emsp;林黛玉心性之强，达到女儿的顶点。她知道湘云、探春都不如她，至于宝琴，更是视之若无，所以很好；但对于宝钗一直心怀恐惧，这个恐惧是一种对于未知的恐惧，她无法明白宝钗的心之所在。宝钗生为女儿身，却并无多少女儿性。","text":"&emsp;&emsp;林黛玉心性之强，达到女儿的顶点。她知道湘云、探春都不如她，至于宝琴，更是视之若无，所以很好；但对于宝钗一直心怀恐惧，这个恐惧是一种对于未知的恐惧，她无法明白宝钗的心之所在。宝钗生为女儿身，却并无多少女儿性。 &emsp;&emsp;林黛玉不会嫉妒袭人，但是她较上了宝钗。真性情之间的关系并不都是友好，经常是非常残酷的。 &emsp;&emsp;宝钗的空和宝玉有所不同，她空而无我，她知道生活毫无意义，所以不会执留，也不会为失败而伤心；但是她又知道这就是全部的意义，所以做一点女红，或安慰母亲，照顾别人。她知道空无，却不会像宝玉一样移情于空无，因为她生性平和，空到了无情可移。她永远不会出家，死，或称为神秘主义者，那都是自怜自艾之人的道路。她会生活下去，成为生活本身。​ &emsp;&emsp;她与生活唯一的不同，是她还看得到虚空和走进虚空的人看见的幻影。也只有她，听清了宝玉最后的不祥之言。 &emsp;&emsp;宝钗无妄想，亦无理想，亦不会破灭，又啥都明白，自可过太平日子。 &emsp;&emsp;她无求无喜，却一切有度，不是无可奈何的折中，确是一种天然的“合适”。这“合适”的法则举世无例，所以也不拘泥。所做大体是公正，名分上的事情自去做，但也无私。对针尖麦芒的黛玉她意外爱护，赠诗送药。小心眼的人读此多以为是她笼络伎俩，其实不然。宝钗还是知人品性，清浊。她看黛玉倒是较宝玉为重。其实她又何尝看得上宝玉。 &emsp;&emsp;薛宝钗根本的体现了中国哲学的另外一个方面，她的屋子里一片雪白，什么都没有。实际上她是最早悟到这白茫茫大地真干净的人了。她不是通过痛苦和思考悟到的，而是天性如此。家里破产，哥哥被抓了，趁有活口，劝她妈妈问问他还欠了别人多少钱，都没钱了，她也无所谓。她是真正无所谓的人，可是她一切事都做，一切都要做的合适。她不求目的，只有合适，这就是中庸之道。这种合适又很微妙：这个人应对这个事，它合适；他们俩之间这样做合适，它是随机应变的，又是先验的。这个合适蕴涵在她的所有内里外在中间。实际上她根本看不上贾宝玉，但她也无所谓。 &emsp;&emsp;她是无所求的人，所以你不能以市俗经验推想她的动机，为什么要什么，她就像“月映万川”，只是现象罢了。 &emsp;&emsp;薛宝钗天然的悟，有一事可以说明。贾宝玉早先看戏，鲁智深有句唱词说“赤条条来去无牵挂”。当即宝玉就落下泪来，黛玉就吃了一惊。宝钗于是说：“坏了，这个人悟了”黛玉说：“哪的事啊，看我问他一问。”黛玉就问了他两句话，宝玉一呆就答不上来，也就不想这件事了。这是他第一次感觉到世界与自己没有关系。那么实际上，宝钗说“坏了”的时候，就已经在前面等着他了。 &emsp;&emsp;中国只有两次描画了人间的天国，一个是陶渊明的桃花源，一个是红楼梦的大观园。 ​&emsp;&emsp;在《红楼梦》里，人无论好坏，只论清浊，其中的女儿性恰恰体现了中国人对于人性和谐的最高梦想。男性化的醒悟往往在于领悟自身的虚幻，将人归于天。而女儿是水做的，无须这种领悟，她们是天化的人，自身就是天上无尘的花朵，在显示冥冥之时，上天也不能不欣赏自己的创作。 ​&emsp;&emsp;我认为《红楼梦》之所以这么漂亮，不在于它仅仅是写好了一个什么故事，或表达了哲学观念，而在于它体现出中国精神一个特别美妙的地方。 ​&emsp;&emsp;这个美妙的部分在西方文学里本来是个绝望的部分，就是浮士德说的“真美呵，你停下来吧”，但是就消失了的那个部分。它不停下来，因为执之者失。这时中国就采取一个什么办法呢？——此时无声胜有声，此处相望不相闻。 ​&emsp;&emsp;任万物自生，如天观世。每个生命的美丽都不去驾驭，自现而自隐，自灭而自生。黛玉和宝玉，爱的那么深切，也没有说，我爱你，一点也没有。它就是两个心的显示过程。","categories":[{"name":"文学","slug":"文学","permalink":"https://yingpengsha.github.io/categories/文学/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://yingpengsha.github.io/tags/文学/"}]}]}